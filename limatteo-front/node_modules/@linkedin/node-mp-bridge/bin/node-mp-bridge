#!/usr/bin/env node

const path = require('path');

const USAGE = `Usage:
    node-mp-bridge [FLAGS] <TASK...>

Where TASK is one of the following tasks (multiple can be specified):

* bower:postinstall
* bower:preuninstall
* yarn:postinstall
* yarn:precommit

The following FLAGS are supported:

  --root        The directory in which package.json exists.  If omitted, the
                current directory will be used.
  --components  [REQUIRED for bower: tasks] A space-separated list (use quotes)
                of the components being modified.
  --milestone   [REQUIRED] The integration milestone to use.  Currently, only
                milestone 1 exists.`;

/** Strips a flag from args and adds it to flags.
 *
 * If the flag is present, it is required to have a value.
 */
function handleFlag(args, flags, flagName, processor) {
  const flagIndex = args.indexOf(`--${flagName}`);
  let value = '';

  if (flagIndex !== -1) {
    if (flagIndex === args.length - 1) {
      console.error(`[node-mp-bridge] [ERROR] You must specify a value for the --${flagName} flag.`);
      console.error();
      console.error(USAGE);
      process.exit(1);
    }

    // Remove the flag and its parameter from args,.
    value = args.splice(flagIndex, 2)[1];
  }

  flags[flagName] = processor(value);
}
const args = process.argv.slice(2);
const flags = {};

handleFlag(args, flags, 'root', value => path.resolve(value));
handleFlag(args, flags, 'components', value => value.split(/\s+/).filter(component => component));
handleFlag(args, flags, 'milestone', value => parseInt(value, 10));

if (!args.length) {
  console.error('[node-mp-bridge] [ERROR] You must specify at least one task.');
  console.error();
  console.error(USAGE);
  process.exit(1);
}

if (!flags.milestone) {
  console.error('[node-mp-bridge] [ERROR] You must specify a milestone.');
  console.error();
  console.error(USAGE);
  process.exit(1);
}

if (flags.root.split(path.sep).includes('node_modules')) {
  // Nothing useful to do when run for a non-root MP.
  process.exit(0);
}

const tasks = {
  'bower:postinstall': [
    null,  // No "milestone zero".
    [updateBowerLockAfterInstall, updateProductSpec],
  ],

  'bower:preuninstall': [
    null,  // No "milestone zero".
    [updateBowerLockBeforeUninstall, updateProductSpec],
  ],

  'yarn:postinstall': [
    null,  // No "milestone zero".
    [updateProductSpec, installBowerComponentsFromLock, checkForVoltaUpdate],
  ],

  'yarn:precommit': [
    null,  // No "milestone zero".
    [updateProductSpec],
  ],

  // The individual tasks exist only for testing; use one of the above,
  // milestone-supporting tasks instead.
  checkForVoltaUpdate,
  installBowerComponentsFromLock,
  updateBowerLockAfterInstall,
  updateBowerLockBeforeUninstall,
  updateProductSpec,
};

const ansicolors = require('ansicolors');
const boxen = require('boxen');
const chalk = require('chalk');
const co = require('co');
const ConfigStore = require('configstore');
const execa = require('execa');
const fs = require('fs-extra');
const gunzipMaybe = require('gunzip-maybe');
const stream = require('stream');
const tarFs = require('tar-fs');
const compareVersions = require('compare-versions');

const { Project, reportTaskTimings, requestWithRetries } = require('../index.js');

const command = `node-mp-bridge ${args.join(' ')}`;
let product;
const start = Date.now();
const taskTimings = [];

function* runTask(task, project, flags) {
  const start = Date.now();
  const success = yield co.wrap(task)(project, flags);

  taskTimings.push({
    task: task.name,
    start,
    duration: Date.now() - start,
  });

  return success;
}

co(function* () {
  console.log(`[node-mp-bridge] Reading ${flags.root}â€¦`);

  const project = new Project(flags.root);
  let commandSuccess = true;

  product = project.productSpecJSON().name;

  for (const taskName of args) {
    const task = tasks[taskName];

    if (task) {
      if (Array.isArray(task)) {
        if (!task[flags.milestone]) {
          throw new Error(`The ${taskName} task does not support milestone '${flags.milestone}'.`);
        }

        for (const subtask of task[flags.milestone]) {
          const taskSuccess = yield co.wrap(runTask)(subtask, project, flags);

          commandSuccess = commandSuccess && taskSuccess;
        }
      } else {
        const taskSuccess = yield co.wrap(runTask)(task, project, flags);

        commandSuccess = commandSuccess && taskSuccess;
      }
    } else {
      throw new Error(`Unknown task '${taskName}'.`);
    }
  }

  return commandSuccess;
}).then(function (success) {
  reportTaskTimings(product, command, flags.milestone, start, Date.now() - start, taskTimings)
    .then(() => process.exit(success ? 0 : 1))
    .catch(err => {
      console.error(`[node-mp-bridge] [WARNING] Could not report task timings: ${err.message}`);
      process.exit(success ? 0 : 1);  // Don't fail the build when metrics can't be reported.
    });
}).catch(function (err) {
  console.error(`[node-mp-bridge] [ERROR] ${err.message}`);

  reportTaskTimings(product, command, flags.milestone, start, Date.now() - start, taskTimings)
    .then(() => process.exit(1))
    .catch(() => process.exit(1));
});

function* checkForVoltaUpdate(/*project, flags*/) {
  // since 0.7.0 it will be available via ECL
  const VERSION_TO_CHECK = "0.7.0";

  // Volta distribution is not handled by a user in CI, so don't try to prompt
  // for an upgrade.
  if ('CI' in process.env) {
    return true;
  }

  // Don't prompt users to upgrade Volta if they're not using it.
  if (!('VOLTA_HOME' in process.env)) {
    return true;
  }

  try {
    const config = new ConfigStore('node-mp-bridge');

    // Don't notify if it's been less than a day since the last notification.
    if (config.has('voltaUpdateLastNotified') && config.get('voltaUpdateLastNotified') + 24 * 60 * 60 * 1000 > Date.now()) {
      return true;
    }

    let currentVersion, latestVersion;

    if ('MOCK_VOLTA' in process.env) {
      currentVersion = process.env.MOCK_VOLTA;
    } else {
      currentVersion = execa.sync(`${process.env.VOLTA_HOME}/volta`, ['--version']).stdout;
    }

    if ('MOCK_ARTIFACTORY' in process.env) {
      latestVersion = process.env.MOCK_ARTIFACTORY;
    } else {
      const request = yield requestWithRetries('GET', 'https://artifactory.corp.linkedin.com:8083/artifactory/api/search/latestVersion?g=com.github.volta-cli&a=volta');

      request.setEncoding('utf8');

      latestVersion = request.read();
    }


    // compareVersions will return 1, 0, or -1 like a sort predicate
    // We only want to show the notification if
    // - the current version is less than 0.7.0
    // - the latest version is greater or equal than 0.7.0
    if (compareVersions(currentVersion, VERSION_TO_CHECK) < 0 && compareVersions(latestVersion, VERSION_TO_CHECK) >= 0) {
      config.set('voltaUpdateLastNotified', Date.now());

      console.log(boxen(`A new version of Volta âš¡ is available! ${ansicolors.red(currentVersion)} â†’ ${ansicolors.green(latestVersion)}
  ${ansicolors.yellow('Changelog:')} ${ansicolors.cyan(`https://github.com/volta-cli/volta/releases/tag/v${latestVersion}`)}
  As of volta@0.7.0, we are moving to distributing volta via ECL/GULL.
  please see ${ansicolors.green('http://go/volta/auto-update')} for how to setup and update!`, {
        align: 'center',
        borderColor: 'yellow',
        borderStyle: 'round',
        margin: 1,
        padding: 1,
      }));
    }

    return true;
  } catch (e) {
    // Errors when checking for a new version of Node shouldn't cause the entire node-mp-bridge run to fail
    return true;
  }
}

function* installBowerComponentsFromLock(project/*, flags*/) {
  // If no lockfile exists, there won't be anything to do, so bail without
  // even logging anything.
  if (!fs.existsSync(project.paths.bowerLock)) {
    return true;
  }

  console.log('[node-mp-bridge] Looking for components to installâ€¦');

  const components = project.getComponentsToInstall();

  console.log(`  Installing ${components.length} components.`);

  for (const component of components) {
    console.log('    * Installing', chalk.green(`${component.originalFolderName}@${component.version}`));

    const componentPath = path.join(project.root, 'bower_components', component.originalFolderName);

    // In case this is an upgrade.
    fs.removeSync(componentPath);
    fs.mkdirsSync(componentPath);

    let source;

    if (process.env.MOCK_ARTIFACTORY) {
      source = new stream.Readable({
        read: () => {
          // This is a TGZ containing only an empty 'package/bower.json'.
          source.push('H4sIAHCl9FoAA+3RSw6CMBSF4S6lK9Dbx7XraQ0xEQMENG5fTICJIw0MiP83ObP2tKfL5zpfqqPZkIgkVWtEU4jvFHFTzqwLPqnzXoNacV6iGKtblpo9hnvuxyql3HJT/37O9I4ld6Kb9i/ts+oP16Ft1r9j/I9TjN/sHyUkY2X9Kp/+fH8AAAAAAAAAAAAAAAAA+/UCFO+kIgAoAAA=', 'base64');
          source.push(null);
        },
      });
    } else {
      source = yield requestWithRetries('GET', component.artifactoryUrl);
    }

    yield new Promise((resolve, reject) => {
      source.on('error', error => reject(new Error(`Could not read from Artifactory: ${error.message}`)));

      const decompressed = source.pipe(gunzipMaybe());

      decompressed.on('error', error => reject(new Error(`Could not decompress artifact: ${error}`)));

      const destination = decompressed.pipe(tarFs.extract(componentPath, {
        chown: false,  // Only applies to root?
        dmode: 0o755,
        fmode: 0o644,
        strip: 1,  // Artifactory tarballs' paths start with 'package/'.
      }));

      destination.on('error', error => reject(new Error(`Could not extract artifact: ${error}`)));
      destination.on('finish', () => resolve());
    });
  }

  console.log('[node-mp-bridge] Finished installing components.');

  return true;
}

function* updateBowerLockAfterInstall(project, flags) {
  console.log('[node-mp-bridge] Updating bower.lockâ€¦');

  let success = true;
  const { updatedLock, installed, missing } = yield co.wrap(project.updatedBowerLock).call(project, flags.components);

  console.log(`  Found ${installed.length} new or updated components.`);

  for (const component of installed) {
    console.log('    *', chalk.green(component));
  }

  if (missing.length) {
    success = false;

    console.error(`  [ERROR] Found ${missing.length} components not available from Artifactory; they must be ELR'ed.  go/elrserver`);

    for (const component of missing) {
      console.error('    *', chalk.red(component));
    }
  }

  // There will always be changes to write, as Bower doesn't call its hooks
  // otherwise.
  writeBowerLock(project, updatedLock);

  return success;
}

function* updateBowerLockBeforeUninstall(project, flags) {
  console.log('[node-mp-bridge] Updating bower.lockâ€¦');

  const { updatedLock, uninstalled } = project.prunedBowerLock(flags.components);

  console.log(`  Found ${uninstalled.length} removed components.`);

  for (const component of uninstalled) {
    console.log('    *', chalk.red(component));
  }

  // There will always be changes to write, as Bower doesn't call its hooks
  // otherwise.
  writeBowerLock(project, updatedLock);

  return true;
}

function* updateProductSpec(project/*, flags*/) {
  // Ignore any product-spec updates when we are dependency testing by noop-ing here.
  // @see https://iwww.corp.linkedin.com/wiki/cf/x/zlSjCw for the definition of DEPENDENT_PRODUCT_NAME
  // Additionally allow opting out of updating product spec via DISABLE_PRODUCTSPEC_UPDATE=true. A primary
  // driver of this is ember-try would attempt to update product spec on each test.
  if (process.env.DEPENDENT_PRODUCT_NAME || process.env.DISABLE_PRODUCTSPEC_UPDATE) {
    return true;
  }
  console.log('[node-mp-bridge] Updating product-spec.jsonâ€¦');

  const { productSpec, added, changed, removed, platformChanged } = project.transformedProductSpec();

  console.log(`  Found ${added.length} new dependencies.`);

  for (const dependency of added) {
    console.log('    *', chalk.green(dependency));
  }

  console.log(`  Found ${changed.length} changed dependencies.`);

  for (const dependency of changed) {
    console.log('    *', chalk.yellow(dependency));
  }

  console.log(`  Found ${removed.length} removed dependencies.`);

  for (const dependency of removed) {
    console.log('    *', chalk.red(dependency));
  }

  if (platformChanged) {
    console.log('  Found change in Node and/or Yarn versions.');
  }

  if (added.length || changed.length || removed.length || platformChanged) {
    if (process.env.CI && !process.env.UPDATE_DEPENDENCY_JOB && (process.env.ALLOW_DEPENDENCY_CHANGES != 'true')) {
      console.error('[node-mp-bridge] [ERROR] Dependency changes detected in CI, aborting.');
      process.exit(1);
    }

    process.stdout.write(`[node-mp-bridge] Writing ${project.paths.product}â€¦`);

    fs.writeFileSync(project.paths.product,
      JSON.stringify(productSpec,
        null,
        project.indents.product.amount));

    console.log(' Done.');
  } else {
    console.log('[node-mp-bridge] No changes needed. ðŸŽ‰')
  }

  return true;
}

function writeBowerLock(project, lock) {
  console.log('[node-mp-bridge] Writing bower.lockâ€¦');

  fs.writeFileSync(project.paths.bowerLock, JSON.stringify(lock, null, project.indents.bowerLock.amount));
}
