'use strict';

const chai = require('chai');
const chaiAsPromised = require('chai-as-promised');
const http = require('http');
const sinon = require('sinon');
const PassThrough = require('stream').PassThrough;
const requestAsPromise = require('../').requestAsPromise;

chai.use(chaiAsPromised);

const expect = chai.expect;

describe('requestAsPromise', function() {
  beforeEach('set up `http.request` stub', function() {
    const request = this.request = new PassThrough();
    const response = this.response = new PassThrough();

    this.stub = sinon.stub(http, 'request').callsFake(() => {
      setTimeout(() => request.emit('response', response), 0);

      return request;
    });
  });

  afterEach('tear down `http.request` stub', function() {
    this.request = null;
    this.response = null;
    this.stub.restore();
  });

  it('returns a Promise', function() {
    expect(requestAsPromise('HEAD', 'http://localhost/')).to.be.a('promise');
  });

  it('creates an HTTP request', function() {
    return requestAsPromise('HEAD', 'http://localhost/').then(() => {
      expect(this.stub.calledOnce).to.be.true;
    });
  });

  it('uses the requested HTTP verb', function() {
    return requestAsPromise('HEAD', 'http://localhost/').then(() => {
      expect(this.stub.firstCall.args[0]).to.include({ method: 'HEAD' });
    });
  });

  it('uses the requested URL', function() {
    return requestAsPromise('HEAD', 'http://localhost/').then(() => {
      expect(this.stub.firstCall.args[0]).to.include({
        // The protocol is implicit, as the `http` module is being used.
        host: 'localhost',
        port: 80,
        path: '/',
      });
    });
  });

  it('rejects on connection error', function() {
    this.stub.reset();

    this.stub.callsFake(() => {
      setTimeout(() => this.request.emit('error', new Error('ECONNREFUSED')), 0);

      return this.request;
    });

    return expect(requestAsPromise('HEAD', 'http://localhost/')).to.be.rejected;
  });

  it('resolves on `statusCode` < 400', function() {
    this.response.statusCode = 200;

    return expect(requestAsPromise('HEAD', 'http://localhost/')).to.be.fulfilled;
  });

  it('rejects on `statusCode` >= 400', function() {
    this.response.statusCode = 400;

    return expect(requestAsPromise('HEAD', 'http://localhost/')).to.be.rejected;
  });

  it('allows the response body to be piped', function() {
    this.response.write('foo');
    this.response.end();

    return requestAsPromise('GET', 'http://localhost/').then(response => {
      const target = new PassThrough();

      expect(() => response.pipe(target)).to.not.throw();

      return new Promise(resolve => {
        response.on('end', () => {
          expect(target.read().toString('utf8')).to.equal('foo');

          resolve();
        });
      });
    });
  });

  it('accepts a string request body', function() {
    return requestAsPromise('POST', 'http://localhost/', 'foo').then(() => {
      expect(this.request.setEncoding('utf8').read()).to.equal('foo');
    });
  });

  it('accepts a Buffer request body', function() {
    return requestAsPromise('POST', 'http://localhost/', Buffer.from('bar')).then(() => {
      expect(this.request.read()).to.deep.equal(Buffer.from('bar'));
    });
  });

  it('accepts an object request body', function() {
    return requestAsPromise('POST', 'http://localhost/', { foo: 'bar', baz: [1, 2, 3] }).then(() => {
      expect(JSON.parse(this.request.setEncoding('utf8').read())).to.deep.equal({ foo: 'bar', baz: [1, 2, 3] });
    });
  });
});
