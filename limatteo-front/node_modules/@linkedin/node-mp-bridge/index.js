'use strict';

const co = require('co');
const detectIndent = require('detect-indent');
const fs = require('fs-extra');
const lockfile = require('@yarnpkg/lockfile');
const os = require('os');
const path = require('path');
const request = require('request');
const sortedObject = require('sorted-object');

const PD_TIMINGS_API = 'https://product-dashboard.tools.corp.linkedin.com/api/v1/timing';

module.exports.Project = class Project {
  constructor(root) {
    this.root = root;

    this.paths = {
      yarn: `${root}/yarn.lock`,
      pkg: `${root}/package.json`,
      product: `${root}/product-spec.json`,
      bower: `${root}/bower.json`,
      bowerComponents: `${root}/bower_components`,
      bowerLock: `${root}/bower.lock`,
    };

    // If validate cannot find product-spec in the above location, it will fall
    // back to looking for it one directory higher.
    this._validate();

    this.indents = {
      yarn: detectIndent(this.yarn()),
      pkg: detectIndent(this.pkg()),
      product: detectIndent(this.productSpec()),
      bower: detectIndent(this.bower()),
      bowerLock: detectIndent(this.bowerLock()),
    };
  }

  _validate() {
    const missing = [];

    if (!fs.existsSync(this.paths.yarn)) {
      missing.push('yarn.lock');
    }

    if (!fs.existsSync(this.paths.pkg)) {
      missing.push('package.json');
    }

    if (!fs.existsSync(this.paths.product)) {
      // In Flyer MPs, product-spec.json is located one directory above the
      // Node package.
      this.paths.product = `${this.root}/../product-spec.json`;

      if (!fs.existsSync(this.paths.product)) {
        missing.push('product-spec.json');
      }
    }

    if (missing.length) {
      throw new Error(`Missing ${missing.join(', ')} in '${this.root}'.`);
    }
  }

  pkg() {
    if ('_pkg' in this) {
      return this._pkg;
    }

    return this._pkg = fs.readFileSync(this.paths.pkg, 'utf8');
  }

  yarn() {
    if ('_yarn' in this) {
      return this._yarn;
    }

    return this._yarn = fs.readFileSync(this.paths.yarn, 'utf8');
  }

  productSpec() {
    if ('_productSpec' in this) {
      return this._productSpec;
    }

    return this._productSpec = fs.readFileSync(this.paths.product, 'utf8');
  }

  bower() {
    if ('_bower' in this) {
      return this._bower;
    }

    return this._bower = fs.existsSync(this.paths.bower) ? fs.readFileSync(this.paths.bower, 'utf8') : '{}';
  }

  bowerLock() {
    if ('_bowerLock' in this) {
      return this._bowerLock;
    }

    return this._bowerLock = fs.existsSync(this.paths.bowerLock) ? fs.readFileSync(this.paths.bowerLock, 'utf8') : '[]';
  }

  pkgJSON() {
    if ('_pkgJSON' in this) {
      return this._pkgJSON;
    }

    return this._pkgJSON = JSON.parse(this.pkg());
  }

  yarnJSON() {
    if ('_yarnJSON' in this) {
      return this._yarnJSON;
    }

    return this._yarnJSON = lockfile.parse(this.yarn());
  }

  productSpecJSON() {
    if ('_productSpecJSON' in this) {
      return this._productSpecJSON;
    }

    return this._productSpecJSON = JSON.parse(this.productSpec());
  }

  bowerJSON() {
    // bower is optional

    if ('_bowerJSON' in this) {
      return this._bowerJSON;
    }

    return this._bowerJSON = JSON.parse(this.bower());
  }

  bowerLockJSON() {
    // bower is optional

    if ('_bowerLockJSON' in this) {
      return this._bowerLockJSON;
    }

    return this._bowerLockJSON = JSON.parse(this.bowerLock());
  }

  getComponentsToInstall() {
    const bowerLock = this.bowerLockJSON();
    const missing = [];

    for (const component of bowerLock) {
      const componentJsonPath = path.join(this.root, 'bower_components', component.originalFolderName, 'bower.json');

      try {
        const componentJson = fs.readJsonSync(componentJsonPath);

        if (component.version !== componentJson.version) {
          // The installed version doesn't match the lock file; flag for
          // reinstall.

          missing.push(component);
        }
      } catch (ex) {
        if (ex instanceof SyntaxError || ex.code === 'ENOENT') {
          // Component is missing or damaged; flag for (re)install.

          missing.push(component);
        } else {
          // Unexpected error.
          throw new Error(`Filesystem error reading '${componentJsonPath}': ${ex.message}`);
        }
      }
    }

    return missing;
  }

  prunedBowerLock(componentsToRemove) {
    const updatedLock = [];
    const uninstalled = [];

    for (const component of this.bowerLockJSON()) {
      if (componentsToRemove.includes(component.originalFolderName)) {
        uninstalled.push(`${component.name}@${component.version}`);
      } else {
        updatedLock.push(component);
      }
    }

    // This will be used by transformedProductSpec.
    this._bowerLockJSON = updatedLock;

    return { updatedLock, uninstalled };
  }

  *updatedBowerLock(componentsToAdd) {
    const bower = this.bowerJSON();
    const elrResolutions = bower.elrResolutions || {};
    const updatedLock = [];
    const installed = [];
    const missing = [];

    for (const originalFolderName of componentsToAdd) {
      const component = fs.readJsonSync(path.join('bower_components', originalFolderName, 'bower.json'));
      const packageName = dasherize(originalFolderName);
      const name = `@components/${packageName}`;
      const intent = elrResolutions[originalFolderName] || bower.dependencies[originalFolderName];
      const version = component.version;
      const artifactoryUrl = `http://dev-artifactory.corp.linkedin.com:8081/artifactory/npm-components/${name}/-/${name}-${version}.tgz`;

      if (!(yield checkUrlExists(artifactoryUrl))) {
        missing.push(`${originalFolderName}@${version}`);
      }

      updatedLock.push({
        dependencies: component.dependencies,
        originalFolderName,
        artifactoryUrl,
        version,
        license: component.license,
        packageName,
        intent,
        name,
      });

      installed.push(`${originalFolderName}@${version}`);
    }

    const originalLock = this.bowerLockJSON();

    for (const component of originalLock) {
      if (!componentsToAdd.includes(component.originalFolderName)) {
        updatedLock.push(component);
      }
    }

    updatedLock.sort((a, b) => {
      if (a.packageName < b.packageName) {
        return -1;
      }

      if (a.packageName > b.packageName) {
        return 1;
      }

      // Can't happen; duplicates are never inserted into the array.
      return 0;
    });

    // This will be used by transformedProductSpec.
    this._bowerLockJSON = updatedLock;

    return { updatedLock, installed, missing };
  }

  transformedProductSpec() {
    // yarn.lock, pkg, productSpec are not optional
    const yarn = this.yarnJSON();
    const pkg = this.pkgJSON();
    const productSpec = this.productSpecJSON();
    const bowerLock = this.bowerLockJSON();

    const external = Object.create(null);
    const product = Object.create(null);

    // Copy `node` and `yarn` version used by Volta in development, if available
    // Stored under key `volta` in `package.json`
    let platformChanged = false;
    if (pkg.volta) {
      const build = productSpec.build || Object.create(null);
      const versions = build.versions || Object.create(null);

      // We explictly check to see if node and/or yarn are listed in
      // product spec for us to update them. This means that if a MP
      // has migrated to volta and no longer has node and yarn listed
      // in product-spec then we will not add it back.

      if (versions.node && versions.node !== pkg.volta.node) {
        versions.node = pkg.volta.node;
        platformChanged = true;
      }

      if (versions.yarn && versions.yarn !== pkg.volta.yarn) {
        versions.yarn = pkg.volta.yarn;
        platformChanged = true;
      }

      build.versions = sortedObject(versions);
      productSpec.build = sortedObject(build);
    }

    // preserve all non `npm:`
    Object.keys(productSpec.external).forEach(key => {
      let value = productSpec.external[key];
      if (value.startsWith('npm:')) { return; }
      external[key] = value;
    });

    // preserve all non `@linkedin/`
    Object.keys(productSpec.product).forEach(key => {
      let value = productSpec.product[key];
      if (value.libraries.find(x => typeof x === 'string' && x.startsWith('@linkedin/'))) {
        return;
      }
      product[key] = value;
    });

    bowerLock.forEach(entry => {
      external[`${entry.packageName}-component`] = `npm:@components/${entry.packageName}:${entry.version}`;
    });

    // populate direct dependents from package.json using yarn.lock to determine exact version used
    topLevelDependencyKeys(pkg).map(key => {
      const parsed = parse(key);

      if (/^(?:file|link):/.test(parsed.intent)) {
        // don't include file: or link: dependencies in sync
        return;
      }

      const dependency = yarn.object[key];
      if (!dependency) throw new Error(`Could not update product-spec.json. Dependency ${key} is missing in yarn.lock. Please run "just yarn check" and fix the errors.`);
      parsed.version = dependency.version;
      return parsed;
    }).filter(Boolean).forEach(parsed => {
      if (parsed.org === '@linkedin') {
        product[parsed.name] = {
          libraries: [
            parsed.fullName
          ],
          version: parsed.version
        }
      } else {
        external[atify(parsed)] = `npm:${parsed.fullName}:${parsed.version}`
      }
    });

    const { added, changed, removed } = dependenciesDiff(productSpec, { external, product });

    productSpec.external = sortedObject(external);
    productSpec.product = sortedObject(product);

    return { productSpec, added, changed, removed, platformChanged };
  }
}

// this mimics @foo/bar encoded to bar-at-foo our existing tooling does
module.exports.atify = atify;
function atify(parsed) {
  if (parsed.org) {
    return `${parsed.name}-at-${parsed.org.replace(/^@/, '')}`;
  }

  return parsed.fullName;
}

/** Checks whether a URL exists.
 *
 * Supports mocking via the MOCK_URLS environment variable.  Set to either
 * 'pass' or 'fail'.
 *
 * @param {string} url The URL to check.
 * @returns {Promise}
 * @fulfilled {boolean} `true` if the URL exists; false, otherwise.
 * @rejected {Error} Connection, client, and server errors.
 */
module.exports.checkUrlExists = co.wrap(checkUrlExists);
function* checkUrlExists(url) {
  if (process.env.MOCK_URLS === 'pass') {
    return true;
  } else if (process.env.MOCK_URLS === 'fail') {
    return false;
  }

  try {
    // Use export binding for mocking by tests.
    yield module.exports.requestWithRetries('HEAD', url);

    return true;
  } catch (error) {
    if (error.statusCode === 404) {
      return false;
    }

    throw new Error(`HTTP error checking for '${url}': ${error.message}`);
  }
}

/** Convert a TitleCased name to kebab-case.
 *
 * ELR appears to dasherize the names of Bower components (e.g.
 * fake-xml-http-request rather than FakeXmlHTTPRequest) and retain a reference
 * to the original name.
 *
 * @param {string} name The name to dasherize.
 * @returns {string} The dasherized name.
 */
module.exports.dasherize = dasherize;
function dasherize(name) {
  return name.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (word, index) {
    return (index > 0 ? '-' : '') + word.toLowerCase();
  });
}

module.exports.dependenciesDiff = dependenciesDiff;
function dependenciesDiff(left, right) {
  const added = [];
  const changed = [];
  const removed = [];

  // Find new and updated external packages.
  for (const [name, version] of entries(right.external)) {
    if (!(name in left.external)) {
      added.push(`${name}@${version.split(':')[2]}`);
    } else if (version !== left.external[name]) {
      changed.push(`${name}@${version.split(':')[2]}`);
    }
  }

  // Find removed external packages.
  for (const [name, version] of entries(left.external)) {
    if (!(name in right.external)) {
      removed.push(`${name}@${version.split(':')[2]}`);
    }
  }

  // Find new and updated internal packages.
  for (const [name, { version }] of entries(right.product)) {
    if (!(name in left.product)) {
      added.push(`@linkedin/${name}@${version}`);
    } else if (version !== left.product[name].version) {
      changed.push(`@linkedin/${name}@${version}`);
    }
  }

  // Find removed internal packages.
  for (const [name, { version }] of entries(left.product)) {
    if (!(name in right.product)) {
      removed.push(`@linkedin/${name}@${version}`);
    }
  }

  return { added, changed, removed };
}

function* entries(object) {
  for (const key in object) {
    yield [key, object[key]];
  }
}

function pkgToYarnLockKey(pkgName, pkgIntent) {
  return `${pkgName}@${pkgIntent}`;
}
function visitPkgDependencies(pkg, reducerFn, initial) {
  // we only consider dependencies and devDependencies
  let acc = initial;
  if (pkg.dependencies) {
    for (let depKey in pkg.dependencies) {
      acc = reducerFn(acc, depKey, pkg.dependencies[depKey]);
    }
  }
  if (pkg.devDependencies) {
    for (let depKey in pkg.devDependencies) {
      acc = reducerFn(acc, depKey, pkg.devDependencies[depKey]);
    }
  }
  return acc;
}

module.exports.topLevelDependencyKeys = topLevelDependencyKeys;

// converts direct dependents into keys in the yarn.lock file
function topLevelDependencyKeys(pkg) {
  return visitPkgDependencies(pkg, (acc, key, value) => {
    acc.push(pkgToYarnLockKey(key, value));
    return acc;
  }, []);
}

module.exports.parse = parse;
function parse(key) {
  const matched = key.match(/^(?:(@[^/@]+)\/)?([^/@]+)@([^@]+)$/);

  if (matched === null) {
    throw new Error(`Unable to parse: '${key}'`);
  }

  const [, org, name, intent] = matched;
  return {
    org,
    name,
    intent,
    fullName: [org, name].filter(Boolean).join('/')
  };
}

/** A task timing object.
 *
 * @typedef {object} Task
 * @param {string} task The name of the task.
 * @param {string} start The task's start time, in milliseconds since the epoch.
 * @param {number} duration The task's run time, in milliseconds.
 */

/** Send task timings to Product Dashboard.
 *
 * @param {string} project The MP the command is being executed for.
 * @param {string} command The node-mp-bridge command run.
 * @param {number} milestone The value of the milestone flag.
 * @param {number} start The command's start time, in milliseconds since the epoch.
 * @param {number} duration The command's run time, in milliseconds.
 * @param {Task[]} tasks An array of tasks and their timings.
 * @returns {Promise}
 * @fulfilled {http.IncomingMessage} A successful response object.
 * @rejected {Error} A connection, client, or server error.
 */
module.exports.reportTaskTimings = reportTaskTimings;
function reportTaskTimings(product, command, milestone, start, duration, tasks) {
  const report = {
    command,
    duration: duration / 1000,
    product,
    start: start / 1000,

    // PD expects task starts to be relative to the command start.
    tasks: tasks.map(task => ({
      task: task.task,
      start: task.start - start,
      duration: task.duration,
    })),

    user: os.hostname(),
  };

  if (milestone) {
    // snake_case for consistency with just.
    report.mp_node_bridge_milestone = milestone;
  }

  if (process.env.SKIP_METRICS) {
    return Promise.resolve();
  } else {
    return module.exports.requestWithRetries('POST', PD_TIMINGS_API, report);
  }
}

// Get the LI Issuer Certificate (caching so it doesn't need to re-load every time)
let certificateCache = false;
function liIssuerCert() {
  if (!certificateCache) {
    certificateCache = fs.readFileSync('/export/apps/openssl/ssl/cert.pem');
  }

  return certificateCache;
}

/** Make a request, wrapped in a Promise.
 *
 * Connection errors and unsuccessful statuses (>=400) are rejected.  If a
 * rejection occurs because of a status code, the status code is added to the
 * error.
 *
 * @param {string} method The HTTP method to use.
 * @param {string} url The URL to connect to.
 * @param {Buffer|string|object} body The request body, if any.  Strings and Buffers are passed as-is.  Objects must be JSON-serializable.
 * @returns {Promise}
 * @fulfilled {http.IncomingMessage} A successful response object.
 * @rejected {Error} A connection, client, or server error.
 */
module.exports.requestAsPromise = requestAsPromise;
function requestAsPromise(method, url, body) {
  return new Promise((resolve, reject) => {
    const options = {
      method,
      url,
      agentOptions: {
        ca: liIssuerCert(),
      },
    };

    if (body) {
      options.body = body;

      if (typeof body !== 'string' && !(body instanceof Buffer)) {
        options.json = true;
      }
    }

    const req = request(options);

    req.on('error', error => {
      // DNS problems, socket failures, and other errors which shouldn't be retried.

      reject(error);
    });

    req.on('response', res => {
      // Preserve the stream for future piping.
      res.pause();

      if (res.statusCode >= 400) {
        const error = new Error(`${res.statusCode} ${res.statusMessage}`);

        error.statusCode = res.statusCode;

        reject(error);
      } else {
        resolve(res);
      }
    });
  });
}

/** Make an HTTP request, retrying on server errors.
 *
 * If a request fails due to a server error (status >=500), it is retried after
 * three seconds up to a total of three attempts.
 *
 * @param {string} method The HTTP method to use.
 * @param {string} url The URL to connect to.
 * @param {Buffer|string|object} body The request body, if any.  Strings and Buffers are passed as-is.  Objects must be JSON-serializable.
 * @param {number} [timeout=3000] The number of milliseconds to wait between attempts.
 * @returns {Promise}
 * @fulfilled {http.IncomingMessage} The response to the request.
 * @rejected {Error} A connection, client, or server error.
 */
module.exports.requestWithRetries = co.wrap(requestWithRetries);
function* requestWithRetries(method, url, body, timeout = 3000) {
  let retries = 2;

  do {
    try {
      // Use export binding for mocking by tests.
      return yield module.exports.requestAsPromise(method, url, body);
    } catch (error) {
      // Only retry server errors.
      if (!error.statusCode || error.statusCode < 500 || !retries) {
        const newError = new Error(`Could not retrieve ${method} '${url}': ${error.message}`);

        // Retain status code for use by e.g. checkUrlExists.
        newError.statusCode = error.statusCode;

        throw newError;
      }

      // Wait three seconds before retrying.
      yield new Promise(resolve => setTimeout(resolve, timeout));
    }
  } while (retries-- > 0);

  console.log('Can\'t happen.  The loop will either return or throw when retries === 0.');
}
