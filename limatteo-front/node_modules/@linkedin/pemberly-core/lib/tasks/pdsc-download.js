const tmp = require('tmp');
const path = require('path');
const fs = require('fs-extra');
const execa = require('execa');
const get = require('lodash.get');
const convert = require('xml-js');
const fetch = require('node-fetch');
const download = require('download');
const Task = require('../helpers/task');
const SilentError = require('silent-error');
const camelCase = require('lodash.camelcase');
const { DEFAULT_DOWNLOAD_DIR } = require('../constants');
const { getPropertyFrom, ARTIFACTORY_URL } = require('../helpers/utils');

const CONFIGURATIONS = ['idl', 'pdsc', 'graphql'];

module.exports = class PdscDownload extends Task {
  constructor({ mpLocation } = {}) {
    super(...arguments);

    if (!mpLocation) {
      throw new SilentError(
        `Missing "mpLocation" argument. Please provide the full path to the mulitproduct.`
      );
    }

    this.name = 'pdsc-download';
    this.mpLocation = mpLocation;
    this.pdscChanged = false;
  }

  /*
   * This is a port of the downloadPDSCArtifacts gradle task that
   * was defined within gradle-pemberly. PDSC's and IDL's were
   * defined within build.gradle but are now defined within package.json
   * as: {
   *    "pemberly": {
   *      "pdsc": ["voyager-api.data-template"]
   *      "idl": ["voyager-api.api"]
   *    }
   * }
   *
   * The result of this task is that artifacts and configs will be created
   * in ./build/ember-cli-pdsc-handler. The ember addon ember-cli-pdsc-handler
   * knows to look in this directory and thus this task must be run
   * before `ember build`.
   */
  async run() {
    this.ui.writeLine('[pemberly-core] PDSC / IDL Task');
    const downloads = [];
    const packageJSONLocation = path.join(this.mpLocation, 'package.json');
    const pemberlyConfig = getPropertyFrom('pemberly', packageJSONLocation, {});
    const downloadDir =
      get(pemberlyConfig, 'downloadDir') || DEFAULT_DOWNLOAD_DIR;
    const downloadLocation = path.join(this.mpLocation, downloadDir);

    const definitions = {
      pdsc: get(pemberlyConfig, 'pdsc', []),
      idl: get(pemberlyConfig, 'idl', []),
      graphql: get(pemberlyConfig, 'graphql'),
    };

    if (Array.isArray(definitions.graphql)) {
      throw new SilentError(
        `[pemberly-core] Only one Graphql Schema configuration can be defined. Found: ${definitions.graphql.join(
          ','
        )}.`
      );
    }

    // the rest of the code expects arrays, so we make sure graphql is also an array
    // after the config is validated
    definitions.graphql = definitions.graphql ? [definitions.graphql] : [];

    if (definitions.pdsc.length === 0 && definitions.idl.length === 0) {
      this.ui.writeLine(`  No PDSCs or IDLs defined in ${packageJSONLocation}`);
    } else {
      this.ui.writeLine(`  PDSCs found: ${definitions.pdsc.length}`);
      this.ui.writeLine(`  IDLs found: ${definitions.idl.length}`);
    }

    const { name: tmpLocation } = tmp.dirSync();
    await fs.ensureDir(downloadLocation);

    for (const config of CONFIGURATIONS) {
      const jsonToBeWritten = { destinations: [], products: {} };

      for (const module of definitions[config]) {
        const [group, name] = module.split('.');

        const {
          configuration,
          version,
          resolvedName,
        } = this.getConfigurationForModule(group, name);

        if (!configuration) {
          throw new SilentError(
            `[pemberly-core] No artifact(s) matching name: '${resolvedName}' with configuration: '${config}'. This is the result of an incorrect configuration within 'product-spec.json'"`
          );
        }

        let ivyFile;
        let ivyContent;

        if (version.includes('-SNAPSHOT')) {
          ivyFile = `${process.env.HOME}/local-repo/com/linkedin/${group}/${resolvedName}/${version}/${resolvedName}-${version}.ivy`;
          ivyContent = this.readIvyFromLocalRepo(ivyFile);
        } else {
          ivyFile = `${ARTIFACTORY_URL}/${group}/${resolvedName}/${version}/${resolvedName}-${version}.ivy`;
          ivyContent = await this.urlToText(ivyFile);
        }

        const artifacts = this.getArtifactsFromIvy(ivyFile, ivyContent);
        const artifactPath = artifacts.find(artifact => {
          // The camelcase is masking an incorrect configuration
          return (
            artifact.conf.includes(configuration) ||
            artifact.conf.includes(camelCase(configuration))
          );
        });

        if (!artifactPath) {
          throw new SilentError(
            `[pemberly-core] Could not find ${configuration} within ${artifacts
              .map(i => i.conf)
              .join(', ')} specified within the ivy file: ${ivyFile}`
          );
        }

        downloads.push(
          this.downloadModuleArtifact(
            downloadDir,
            artifactPath,
            tmpLocation,
            group,
            resolvedName,
            version
          )
        );

        jsonToBeWritten.destinations.push(
          `${downloadDir}/${group}/${resolvedName}/${version}`
        );

        if (!get(jsonToBeWritten, `products.${group}.libraries`, false)) {
          jsonToBeWritten.products[group] = { libraries: [], version: '' };
        }

        jsonToBeWritten.products[group].libraries.push(resolvedName);
        jsonToBeWritten.products[group].version = version;
      }

      // Allow concurent downloads
      await Promise.all(downloads);

      await fs.writeJson(
        `${downloadLocation}/${config}-artifacts.json`,
        jsonToBeWritten,
        { spaces: 4 }
      );
    }

    if (this.pdscChanged) {
      this.ui.writeLine(
        `  PDSCs, IDLs, GraphQL schema and artifact files have been created at ${path.join(
          this.mpLocation,
          downloadDir
        )}`
      );
    } else {
      this.ui.writeLine('  No changes needed');
    }
  }

  // This is a temp solution, end goal is that these packages will be published
  // to artifactory's npm registry and downloaded via yarn
  async downloadModuleArtifact(
    downloadDir,
    artifactPath,
    location,
    group,
    name,
    version
  ) {
    const downloadLocation = `${location}/${group}/${name}/${version}`;
    const downloadFilename = `${artifactPath.path}-${version}.jar`;
    const downloadUrl = `${ARTIFACTORY_URL}/${group}/${name}/${version}/${downloadFilename}`;
    const cacheLocation = path.join(
      this.mpLocation,
      downloadDir,
      `${group}/${name}/${version}`
    );

    if (!fs.existsSync(cacheLocation)) {
      this.pdscChanged = true;

      await fs.ensureDir(downloadLocation);

      if (version.includes('-SNAPSHOT')) {
        this.ui.writeLine(
          `  Copying from local-repo: ${group}.${name}@${version}`
        );
        // copy files from local-repo to the download location
        await fs.copy(
          `${process.env.HOME}/local-repo/com/linkedin/${group}/${name}/${version}/${downloadFilename}`,
          `${downloadLocation}/${downloadFilename}`
        );
      } else {
        this.ui.writeLine(`  Downloading: ${group}.${name}@${version}`);
        await download(downloadUrl, downloadLocation, { agent: null });
      }

      await execa.shell(`unzip ${downloadFilename}`, { cwd: downloadLocation });
      await fs.remove(path.join(downloadLocation, downloadFilename));
      await fs.move(downloadLocation, cacheLocation);
    }
  }

  async urlToText(ivyFile) {
    const rawIvyContent = await fetch(ivyFile);
    const ivyContent = await rawIvyContent.text();

    return ivyContent;
  }

  readIvyFromLocalRepo(ivyFile) {
    return fs.readFileSync(ivyFile, 'utf8');
  }

  getArtifactsFromIvy(ivyFile, ivyContent) {
    let ivyJSON;

    try {
      const jsonString = convert.xml2json(ivyContent, { compact: true });
      ivyJSON = JSON.parse(jsonString);
    } catch (e) {
      if (typeof e === 'object' && e !== null) {
        e.message = `[pemberly-core] Error parsing ivy file:\n\n${ivyFile}\n\n${e.message}`;
      }

      throw e;
    }

    let ivyArtifact = get(ivyJSON, 'ivy-module.publications.artifact');

    if (!Array.isArray(ivyArtifact)) {
      ivyArtifact = [ivyArtifact];
    }

    return ivyArtifact.map(art => {
      return {
        conf: get(art, '_attributes.conf'),
        path: get(art, '_attributes.name'),
      };
    });
  }

  getConfigurationForModule(group, name) {
    const productSpecPath = path.join(this.mpLocation, 'product-spec.json');
    const moduleSpec = getPropertyFrom(
      `product.${group}`,
      productSpecPath,
      false
    );

    if (!moduleSpec) {
      throw new SilentError(
        `Could not find '${group}.${name}' defined within product-spec.json`
      );
    }

    let configuration = get(moduleSpec, 'libraries', []).find(lib => {
      if (typeof lib === 'string') {
        return lib === name;
      }

      if (lib.key) {
        return lib.key === name;
      }

      return lib.name === name;
    });

    if (configuration === undefined) {
      throw new SilentError(
        `Could not find "${name}" defined within "${group}" in product-spec.json.\nMust be either a key or name if key is not defined from the following: \n\n${JSON.stringify(
          moduleSpec,
          null,
          2
        )}`
      );
    }

    const resolvedName = configuration.name || name;

    if (typeof configuration !== 'string') {
      ({ configuration } = configuration);
    }

    return { resolvedName, configuration, version: get(moduleSpec, 'version') };
  }
};
