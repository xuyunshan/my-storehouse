const os = require('os');
const tmp = require('tmp');
const path = require('path');
const fs = require('fs-extra');
const execa = require('execa');
const SilentError = require('silent-error');
const depsFor = require('hash-for-dep/lib/deps-for');
const Task = require('../helpers/task');
const { getPropertyFrom, fetch, ARTIFACTORY_URL } = require('../helpers/utils');

module.exports = class ClientTarball extends Task {
  constructor({ mpLocation } = {}) {
    super(...arguments);

    this.name = 'pack';
    this.mpLocation = mpLocation;
  }

  getNodeVersionFromMp() {
    let nodeVersion = getPropertyFrom(
      'build.versions.node',
      path.join(this.mpLocation, 'product-spec.json'),
      false
    );

    if (!nodeVersion) {
      nodeVersion = getPropertyFrom(
        'volta.node',
        path.join(this.mpLocation, 'package.json'),
        false
      );
    }

    return nodeVersion;
  }

  async run() {
    this.ui.writeLine(`\n[pemberly-core] Building client side tarball`);
    const packageLocation = path.join(this.mpLocation, 'package.json');

    const MP_NAME = getPropertyFrom('name', packageLocation);
    const MP_VERSION = getPropertyFrom('version', packageLocation);
    const nodeVersion = this.getNodeVersionFromMp();

    // these can be removed once yarn pack is fixed and released https://github.com/yarnpkg/yarn/pull/6908
    const packageFiles = getPropertyFrom('files', packageLocation, []);
    const bundleDependencies = getPropertyFrom(
      'bundledDependencies',
      packageLocation,
      []
    );

    const tmpobj = tmp.dirSync();
    const tmpDestination = path.join(tmpobj.name, 'package');
    fs.ensureDirSync(tmpDestination);

    await this.setupNode(nodeVersion, tmpDestination);

    // TODO add warning if nothing found in files or bundleDependencies
    this.ui.writeLine(
      `  Found "${packageFiles.join(', ')}" defined in ${packageLocation}`
    );
    this.ui.writeLine(
      `  Found "${bundleDependencies.join(', ')}" defined in ${packageLocation}`
    );

    // these can be removed once yarn pack is fixed and released https://github.com/yarnpkg/yarn/pull/6908
    this.yarnPack(packageFiles, bundleDependencies, tmpDestination);

    await execa('tar', ['czf', `${MP_NAME}-${MP_VERSION}.tgz`, 'package'], {
      cwd: tmpobj.name,
    });

    const tarballName = `${tmpobj.name}/${MP_NAME}-${MP_VERSION}.tgz`;
    const buildTarballLocation = path.resolve(
      `${this.mpLocation}/build/pemberly-core/${MP_NAME}-${MP_VERSION}.tgz`
    );

    await fs.ensureDir(`${this.mpLocation}/build/pemberly-core`);
    await fs.copy(tarballName, buildTarballLocation);
  }

  /*
   * As apart of the tarball that is passed into gradle it has a node subdirectory such
   * as package/node/*. This function downloads the node tarball of a given version to
   * a given location and unpacks it.
   */
  async setupNode(version, location) {
    await this.downloadNode(version, location);

    try {
      await execa('tar', ['-xf', `node.tar.gz`], { cwd: location });
      await fs.remove(path.join(location, 'node.tar.gz'));
      await fs.move(
        path.join(location, `node-v${version}-${os.platform()}-${os.arch()}`),
        path.join(location, 'node')
      );
    } catch (e) {
      throw new SilentError(
        `Could not untar node ${version} at ${location}\n${e.message}`
      );
    }
  }

  /*
   * This is a tmp hack while yarn + bundledDeps do not work.
   * Once yarn pack starts working this whole function can
   * be removed.
   */
  yarnPack(packageFiles, bundleDependencies, location) {
    for (const file of packageFiles) {
      fs.copySync(file, path.join(location, file));
    }

    if (bundleDependencies) {
      for (const dependency of bundleDependencies) {
        const dependencyList = depsFor(dependency, process.cwd(), {
          includeOptionalDeps: true,
        });

        if (dependencyList.length === 0) {
          throw new SilentError(
            `\nCould not find "${dependency}". Please make sure that this package is spelled correctly and is also listed in the dependencies section.`
          );
        }

        this.ui.writeLine(
          `  Including "${dependency}" as a bundledDependency which will bring in ${dependencyList.length} sub dependencies`
        );

        for (const dep of dependencyList) {
          fs.copySync(
            path.relative('.', dep.baseDir),
            path.join(location, path.relative('.', dep.baseDir)),
            { dereference: true }
          );
        }
      }
    }
  }

  async resolveArtifact() {
    try {
      const { stdout } = await execa('resolve-artifact', [
        'ivy:/com.linkedin.nodejs/nodejs/',
      ]);

      return stdout;
    } catch (e) {
      throw new SilentError(`Error connecting to artifactory\n${e.message}`);
    }
  }

  findClosestVersion(ivyResult, nodeVersion) {
    const versions = ivyResult
      .split('\n')
      .map(line => line.split('com/linkedin/nodejs/nodejs/')[1]);
    const foundVersion = versions.filter(v => v.startsWith(nodeVersion));

    if (foundVersion.length > 1) {
      foundVersion.sort((a, b) => {
        return b.split('.')[3] - a.split('.')[3];
      });
    }

    if (foundVersion.length === 0) {
      throw new SilentError(
        `Node ${nodeVersion} does not exist in artifactory.`
      );
    }

    return foundVersion[0];
  }

  /*
   * Download node from artifactory. In artifactory, node versions are stored with 4 digits
   * (like 10.6.0.1). This last digit is not defined within project-spec and must be "guessed".
   * To view all versions:
   *
   * http://artifactory.corp.linkedin.com:8081/artifactory/release/com/linkedin/nodejs/nodejs/
   */
  async downloadNode(version, location) {
    try {
      const ivyResult = await this.resolveArtifact(version);
      const fullNodeVersion = this.findClosestVersion(ivyResult, version);

      const nodePackageName = `nodejs-${fullNodeVersion}-${os.platform()}-${os.arch()}`;
      const downloadUrl = `${ARTIFACTORY_URL}/nodejs/nodejs/${fullNodeVersion}/${nodePackageName}.tar.gz`;

      await fetch(`${location}/node.tar.gz`, downloadUrl);
    } catch (e) {
      throw new SilentError(`Failed to download node ${version}\n${e.message}`);
    }
  }
};
