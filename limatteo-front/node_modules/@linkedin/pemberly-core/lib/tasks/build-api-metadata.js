const fs = require('fs');
const moment = require('moment');
const execa = require('execa');
const path = require('path');
const rimraf = require('rimraf');
const walkSync = require('walk-sync');
const yargs = require('yargs/yargs');
const js2xml = require('js2xmlparser');
const Task = require('../helpers/task');

// See the spec for additional details & comments at:
// http://go/pemberly-data/npm-rfc

/**
 * Handle options for build-api-metadata.  These include
 *
 *  --package-name STRING
 *
 *  Name for the NPM package.  Defaults to @linkedin/${mpName}-spec.
 *
 *  --package-version STRING
 *
 *  Version of the npm package.  Required if build-api-metadata is called
 *  without first having called mint build.  Otherwise, version will default to
 *  the one computed in build/dependency-spec.json.
 *
 *  --target PATH
 *
 *  Where to build the npm package.  Useful for `npm link`ing when developing
 *  locally against both web and api MPs.  Defaults to build/api-metadata.
 *
 *  --tarball-only BOOLEAN
 *
 *  Whether or not to only build a tarball, or to also setup mint files for
 *  publication to artifactory. Defaults to false.
 *
 *  --pdsc-roots PATH [, PATH...]
 *
 *  Directories to search (recursively) for data model metadata (PDSCs).
 *
 *  --pdsc-pattern PATTERN
 *
 *  Glob for matching files in pdsc roots.  Defaults to **\/*.pdsc
 *
 *  --idl-roots PATH [, PATH...]
 *
 *  Directories to search (recursively) for api resource metadata (idls).
 *
 *  --idl-pattern PATTERN
 *
 *  Glob for matching files in idl roots.  Defaults to **\/*.restspec.json
 *
 *  --microschema-roots PATH [, PATH...]
 *
 *  Directories to search (recursively) for frontend-deco recipe metadata (microschemas).
 *
 *  --microschema-pattern PATTERN
 *
 *  Glob for matching files in microschema roots.  Defaults to **\/*.recipespec.json
 *
 *  --graphql-roots PATH [, PATH...]
 *
 *  Directories to search (recursively) for federated graphql schemas.
 *
 *  --graphql-pattern PATTERN
 *
 *  Glob for matching files in graphql roots.  Defaults to **\/federated.graphql.
 *
 *  --debug BOOLEAN
 *
 *  When enabled, outputs extra logging.  Defaults to false.
 *
 */
class Options {
  constructor(argv, mpLocation) {
    const raw = this._parseOptions(argv);
    const productSpecPath = path.join(mpLocation, 'product-spec.json');
    if (!fs.existsSync(productSpecPath)) {
      throw new Error(`Cannot find product-spec.json at '${productSpecPath}'`);
    }
    const productSpec = JSON.parse(fs.readFileSync(productSpecPath));

    this.raw = raw;
    this.mpLocation = mpLocation;
    this._productSpec = productSpec;

    this._depSpecPath = path.join(this._buildPath, 'dependency-spec.json');
    if (fs.existsSync(this._depSpecPath)) {
      this._depSpec = JSON.parse(fs.readFileSync(this._depSpecPath));
    } else if (!this.tarballOnly) {
      throw new Error(
        `Cannot find dependency-spec at '${this._depSpecPath}'; did you forget to run 'mint build' first?`
      );
    }

    this._artifactSpecPath = path.join(this._buildPath, 'artifact-spec.json');
    if (fs.existsSync(this._artifactSpecPath)) {
      this._artifactSpec = JSON.parse(fs.readFileSync(this._artifactSpecPath));
    } else if (!this.tarballOnly) {
      throw new Error(
        `Cannot find artifact-spec at '${this._artifactSpecPath}'; did you forget to run 'mint build' first?`
      );
    }

    if (this.tarballOnly && this.packageVersion === undefined) {
      throw new Error(
        `Cannot determine package version.  When using --tarball-only wihtout having first run a mint build you must include --package-version`
      );
    }
  }

  _parseOptions(argv = []) {
    const cmdIdx = argv.findIndex(
      x => x.toLowerCase() === 'build-api-metadata'
    );
    if (cmdIdx === -1) {
      throw new Error(
        `[pemberly-core internal error]: argv does not contain command name; was: '${argv.join(
          ' '
        )}'`
      );
    }
    const args = yargs(argv.slice(cmdIdx + 1))
      .option('package-name', { type: 'string' })
      .option('target', { type: 'string' })
      .option('tarballOnly', { type: 'boolean' })
      .option('debug', { type: 'boolean' })
      .option('pdsc-roots', { type: 'array' })
      .option('pdsc-pattern', { type: 'string' })
      .option('idl-roots', { type: 'array' })
      .option('idl-pattern', { type: 'string' })
      .option('microschema-roots', { type: 'array' })
      .option('microschema-pattern', { type: 'string' })
      .option('graphql-roots', { type: 'array' })
      .option('graphql-pattern', { type: 'string' }).argv;

    return args;
  }

  get debug() {
    return 'debug' in this.raw ? this.raw.debug : false;
  }

  get packageName() {
    return 'packageName' in this.raw
      ? this.raw.packageName
      : `@linkedin/${this._mpName}-spec`;
  }

  get target() {
    return 'target' in this.raw
      ? path.resolve(this.raw.target)
      : path.join(this._buildPath, 'api-metadata');
  }

  get tarballOnly() {
    return 'tarballOnly' in this.raw ? this.raw.tarballOnly : false;
  }

  get pdscRoots() {
    return 'pdscRoots' in this.raw ? this.raw.pdscRoots : [];
  }

  get pdscPattern() {
    return 'pdscPattern' in this.raw ? this.raw.pdscPattern : '**/*.pdsc';
  }

  get idlRoots() {
    return 'idlRoots' in this.raw ? this.raw.idlRoots : [];
  }

  get idlPattern() {
    return 'idlPattern' in this.raw
      ? this.raw.idlPattern
      : '**/*.restspec.json';
  }

  get microschemaRoots() {
    return 'microschemaRoots' in this.raw ? this.raw.microschemaRoots : [];
  }

  get microschemaPattern() {
    return 'microschemaPattern' in this.raw
      ? this.raw.microschemaPattern
      : '**/*.recipespec.json';
  }

  get graphqlRoots() {
    return 'graphqlRoots' in this.raw ? this.raw.graphqlRoots : [];
  }

  get graphqlPattern() {
    return 'graphqlPattern' in this.raw
      ? this.raw.graphqlPattern
      : '**/federated.graphql';
  }

  get _unscopedPackageName() {
    return this.packageName.replace(/^@linkedin\//, '');
  }

  get _buildPath() {
    return path.join(this.mpLocation, 'build');
  }

  get _tarballPath() {
    return path.join(
      this.target,
      `${this._artifactScopedName}-${this.packageVersion}.tgz`
    );
  }

  get _ivyPath() {
    return path.join(
      this._buildPath,
      'ivy-files',
      `${this._artifactUnscopedName}-${this.packageVersion}.ivy`
    );
  }

  get _mpName() {
    return this._productSpec.name;
  }

  get _artifactUnscopedName() {
    return this._unscopedPackageName;
  }

  get _artifactScopedName() {
    return `linkedin-${this._artifactUnscopedName}`;
  }

  get packageVersion() {
    if ('packageVersion' in this.raw) {
      return this.raw.packageVersion;
    }

    // check for depSpec so we can throw a graceful error when user passes
    // --tarball-only without --package-version
    if (this._depSpec !== undefined) {
      // Can't read from product-spec as it is likely a pattern and not a
      // specific version
      return this._depSpec.version;
    }

    return undefined;
  }
}

module.exports = class BuildApiMetadata extends Task {
  constructor({ mpLocation } = {}) {
    super(...arguments);

    this.name = 'build-api-metadata';
    this.mpLocation = mpLocation;
  }

  run(argv = process.argv) {
    const options = new Options(argv, this.mpLocation);
    if (options.debug !== false) {
      this.ui.writeLevel = 'DEBUG';
    }

    this.ui.writeDebugLine(
      `build-api-metadata\nmp: ${this.mpLocation}\noptions:\n${JSON.stringify(
        options,
        null,
        2
      )}\n`
    );

    this._buildPackage(options);
    this._packPackage(options);

    if (options.tarballOnly !== true) {
      this._buildMintSpecFiles(options);
    }
  }

  _buildPackage(options) {
    this._rimrafTargetPackage(options);
    fs.mkdirSync(options.target, {
      recursive: true,
    });
    this._writePackageJson(options);
    this._copyPdscs(options);
    this._copyIdls(options);
    this._copyMicroschemas(options);
    this._copyGraphqlSchemas(options);
  }

  _packPackage(options) {
    execa.sync('npm', ['pack'], { cwd: options.target });
  }

  _buildMintSpecFiles(options) {
    this._updateDependencySpec(options);
    this._writeIvyFile(options);
    this._updateArtifactSpec(options);
  }

  _rimrafTargetPackage(options) {
    const { target } = options;

    if (!fs.existsSync(target)) {
      return;
    }

    // safety checks before rm -rf
    const parts = target.split(path.sep);
    if (parts.length < 3 || !parts.includes('build')) {
      throw new Error(
        `Refusing to rm -rf '${target}': expecting this path to be the build dir of an MP`
      );
    }

    this.ui.writeDebugLine(`clearing old package: ${target}`);
    rimraf.sync(target);
  }

  _writePackageJson(options) {
    const packageJsonPath = `${options.target}/package.json`;
    fs.writeFileSync(
      packageJsonPath,
      JSON.stringify(
        {
          name: options.packageName,
          version: options.packageVersion,
          description: `API metadata for ${options._mpName}`,
          files: ['metadata-v1'],
        },
        null,
        2
      )
    );
  }

  _copyPdscs(options) {
    this._copyMetadata(
      options.target,
      'pdscs',
      options.pdscRoots,
      options.pdscPattern
    );
  }

  _copyIdls(options) {
    this._copyMetadata(
      options.target,
      'idls',
      options.idlRoots,
      options.idlPattern
    );
  }

  _copyMicroschemas(options) {
    this._copyMetadata(
      options.target,
      'recipespecs',
      options.microschemaRoots,
      options.microschemaPattern
    );
  }

  _copyGraphqlSchemas(options) {
    this._copyMetadata(
      options.target,
      'graphql',
      options.graphqlRoots,
      options.graphqlPattern
    );
  }

  _copyMetadata(packageTarget, type, roots, pattern) {
    const metadataTarget = path.join(packageTarget, `metadata-v1`, type);
    fs.mkdirSync(metadataTarget, { recursive: true });

    roots.forEach(root => {
      if (!fs.existsSync(root)) {
        this.ui.writeInfoLine(`No such ${type} root: '${root}'`);
      }

      const paths = walkSync(root, {
        directories: false,
        globs: [pattern],
      });
      paths.forEach(p => {
        this.ui.writeDebugLine(`Found ${type}: ${p}`);
        const target = `${metadataTarget}/${p.replace(/\//g, '.')}`;
        const src = path.join(root, p);
        fs.copyFileSync(src, target);
      });
    });
  }

  _updateDependencySpec(options) {
    const depSpec = options._depSpec;
    if (depSpec.archive === null || typeof depSpec.archive !== 'object') {
      depSpec.archive = {};
    }
    const { archive } = depSpec;
    if (
      archive.repository_overrides === null ||
      typeof archive.repository_overrides !== 'object'
    ) {
      archive.repository_overrides = {};
    }
    const repoOverrides = archive.repository_overrides;
    if (!Array.isArray(repoOverrides['npm-internal'])) {
      repoOverrides['npm-internal'] = [];
    }
    const npmOverrides = repoOverrides['npm-internal'];

    [options._artifactUnscopedName, options._artifactScopedName].forEach(
      artifactName => {
        if (!npmOverrides.includes(artifactName)) {
          npmOverrides.push(artifactName);
        }
      }
    );

    fs.writeFileSync(options._depSpecPath, JSON.stringify(depSpec, null, 2));
  }

  _writeIvyFile(options) {
    const {
      _ivyPath,
      packageVersion,
      _artifactUnscopedName,
      _mpName,
    } = options;
    const pubTimeStr = moment().format('YYYYMMDDHHmmss');
    const ivyObj = {
      '@': {
        version: '2.0',
        'xmlns:m': 'http://ant.apache.org/ivy/maven',
      },
      info: {
        '@': {
          organization: `com.linkedin.${_mpName}`,
          module: _artifactUnscopedName,
          revision: packageVersion,
          status: 'integration',
          publication: pubTimeStr,
        },
      },
      configurations: {
        conf: [
          { '@': { name: 'archives', visibility: 'public' } },
          { '@': { name: 'default', visibility: 'public' } },
          { '@': { name: 'gcc', visibility: 'public' } },
          { '@': { name: 'jacocoAgent', visibility: 'private' } },
          { '@': { name: 'node', visibility: 'public' } },
          { '@': { name: 'yarn', visibility: 'public' } },
        ],
      },
      publications: {
        artifact: [
          {
            '@': {
              name: _artifactUnscopedName,
              type: 'lib',
              ext: 'tgz',
              conf: 'archives,default',
            },
          },
        ],
      },
      dependencies: {
        dependency: [
          {
            '@': {
              org: 'org.linkedin.gcc',
              name: 'gcc',
              rev: '4.8.3.9',
              conf: 'gcc-&gt;default',
            },
            artifact: {
              '@': {
                name: 'gcc-linux-x64',
                type: 'tgz',
                ext: 'tgz',
                conf: 'gcc',
              },
            },
          },
          {
            '@': {
              org: 'org.jacoco',
              name: 'org.jacoc.agent',
              rev: '0.7.6.201602180812',
              conf: 'jacocoAgent-&gt;default',
            },
          },
          {
            '@': {
              org: 'org.jacoco',
              rev: '0.7.6.201602180812',
              conf: 'jacocoAnt-&gt;default',
            },
          },
          {
            '@': {
              org: 'com.linkedin.nodejs',
              name: 'nodejs',
              rev: '10.6.0.+',
              transitive: 'false',
              conf: 'node-&gt;default',
            },
            artifact: {
              '@': {
                name: 'nodejs',
                type: 'tar.gz',
                ext: 'tar.gz',
                'm:classifier': 'darwin-x64',
                conf: 'node',
              },
            },
          },
          {
            '@': {
              org: '',
              name: 'yarn',
              rev: '1.17.0',
              transitive: 'false',
              conf: 'yarn-&gt;default',
            },
            artifact: {
              '@': { name: 'yarn', type: 'tgz', ext: 'tgz', conf: 'yarn' },
            },
          },
        ],
      },
    };
    fs.mkdirSync(path.dirname(_ivyPath), { recursive: true });
    fs.writeFileSync(_ivyPath, js2xml.parse('ivy-module', ivyObj));
  }

  _updateArtifactSpec(options) {
    const {
      _artifactSpecPath: artifactSpecPath,
      _artifactSpec: artifactSpec,
      _artifactUnscopedName,
      _artifactScopedName,
      _ivyPath,
      _tarballPath,
    } = options;

    if (
      artifactSpec.artifacts === null ||
      typeof artifactSpec.artifacts !== 'object'
    ) {
      artifactSpec.artifacts = {};
    }
    const { artifacts } = artifactSpec;
    const ivyAbsPath = path.resolve(_ivyPath);
    const tarballFullPath = path.resolve(_tarballPath);
    const ivyUrl = `ivy:/com.linkedin.${_artifactUnscopedName}/${_artifactUnscopedName}/1.2.3`;
    artifacts[_artifactUnscopedName] = {
      ivyFile: ivyAbsPath,
      ivy: ivyUrl,
    };
    artifacts[_artifactScopedName] = {
      Artifact: tarballFullPath,
      ivyFile: ivyAbsPath,
      ivy: ivyUrl,
    };
    fs.writeFileSync(artifactSpecPath, JSON.stringify(artifactSpec, null, 2));
  }
};

// exported for testing
module.exports._Options = Options;
