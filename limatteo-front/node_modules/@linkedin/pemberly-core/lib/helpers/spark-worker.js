const os = require('os');
const path = require('path');
const Zlib = require('zlib');
const execa = require('execa');
const fs = require('fs-extra');
const workerpool = require('workerpool');

const compressors = {
  br: {
    compress(inputPath, outputPath) {
      const platform = os.platform() === 'darwin' ? 'macosx' : 'linux';
      const binary = path.resolve(
        __dirname,
        `./brotli/brotli-0.5.2-LI1.${platform}`
      );
      return execa(binary, [
        '--quality',
        '11',
        '--input',
        inputPath,
        '--output',
        outputPath,
      ]);
    },
  },
  gzip: {
    compress(inputPath, outputPath) {
      const gzip = Zlib.createGzip({ level: 9 });
      const inp = fs.createReadStream(inputPath);
      const out = fs.createWriteStream(outputPath);

      return new Promise(resolve => {
        inp
          .pipe(gzip)
          .pipe(out)
          .on('finish', () => resolve());
      });
    },
  },
};

/*
 * Compresses given files using the given compressor.
 * It writes files to the same directory as the original file and returns an
 * array of error strings.
 */
function compressPaths(filePath, contentEncoding, distPath) {
  const errors = [];
  const compressedFilename = `${distPath}/${filePath}.${
    contentEncoding === 'gzip' ? 'gz' : contentEncoding
  }`;

  if (fs.pathExistsSync(compressedFilename)) {
    errors.push(
      `asset already exists with name as ${contentEncoding} compression target: ${compressedFilename}`
    );
  } else {
    return compressors[contentEncoding].compress(
      path.resolve(distPath, filePath),
      path.resolve(compressedFilename),
      compressedFilename
    );
  }

  return errors;
}

workerpool.worker({ compressPaths });
