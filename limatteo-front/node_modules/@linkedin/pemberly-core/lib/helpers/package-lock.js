/**
 * THIS IS FOR SUPPORTING LEGACY MP ONLY
 * in multiproducts which haven't been migrated to yarn
 * when running build process using gradle-pemberly
 * dependencyBuildPreparationTask requires a package.lock file in each installed dependency
 *
 * As the result
 * in prepack task we are calling a jar file from gradle pemberly to create package.lock
 * and pack the package.lock into the tarball
 * then we remove the package.lock in postpack task
 *
 * After yarn migration gradle-pemberly will look for yarn.lock instead
 * Doc for yarn migration: go/yarn-migration
 *
 */
const fs = require('fs-extra');
const execa = require('execa');
const path = require('path');
const SilentError = require('silent-error');

/**
 * Create pakcage.lock file via calling package-lock.jar
 *
 * @param {String} rootPath
 * @returns {Promise}
 */
async function createPackageLock(mpLocation) {
  const jarFilePath = path.join(__dirname, 'jars/package-lock.jar');
  try {
    // run jar file and write output to package.lock
    const javaProcess = execa('java', ['-jar', jarFilePath, mpLocation]);
    javaProcess.stdout.pipe(
      fs.createWriteStream(path.join(mpLocation, 'package.lock'))
    );
    await javaProcess;
  } catch (e) {
    throw new SilentError(
      `[pre-pack]: Failed to create package.lock in ${mpLocation}`
    );
  }
}
/**
 * Delete pakcage.lock file
 *
 * @param {String} rootPath
 * @returns {Promise}
 */
async function deletePackageLock(mpLocation) {
  const packageLockFile = path.join(mpLocation, 'package.lock');
  try {
    await fs.unlink(packageLockFile);
  } catch (e) {
    throw new SilentError(
      `[post-pack]: Failed to clean package.lock in ${mpLocation}`
    );
  }
}

module.exports.createPackageLock = createPackageLock;
module.exports.deletePackageLock = deletePackageLock;
