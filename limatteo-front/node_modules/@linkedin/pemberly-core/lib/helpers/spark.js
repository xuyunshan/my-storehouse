const path = require('path');
const fs = require('fs-extra');

function isRemoteUrl(url) {
  return (
    url.startsWith('//') ||
    url.startsWith('http://') ||
    url.startsWith('https://')
  );
}

function isInlineData(url) {
  return url
    .toLowerCase()
    .replace('"', '')
    .replace("'", '')
    .startsWith('data:');
}

function duplicateSparkEntries(prefix, hashes) {
  const duplicatedHashes = {};

  Object.entries(hashes).forEach(([key, value]) => {
    duplicatedHashes[key] = value;
    duplicatedHashes[`${prefix}${key}`] = value;
  });

  return duplicatedHashes;
}

/*
 * Check if file size is larger than Sparks asset size limit (1500Kb). If
 * it is then split the file into its parts and write them to disk.
 *
 * If a file (say vendor.js) is too large it will be split up like:
 *
 * vendor.js
 * vendor.js-PARTS/parts-1-vendor.js
 * vendor.js-PARTS/parts-2-vendor.js
 * vendor.js-PARTS/parts-3-vendor.js
 *
 * Where each file has a size <= SPARK_ASSET_SIZE_LIMIT.
 *
 * Returns an array of paths (could include parts)
 */
function splitFileLargerThanSparkAssetSizeLimit(filePath) {
  const paths = [];
  const stats = fs.statSync(filePath);
  const SPARK_ASSET_SIZE_LIMIT = 1500 * 1024;

  if (stats.size > SPARK_ASSET_SIZE_LIMIT) {
    const fileBuffer = fs.readFileSync(filePath);
    const parsePath = path.parse(filePath);

    for (
      let i = 0;
      i < Math.ceil(fileBuffer.length / SPARK_ASSET_SIZE_LIMIT);
      i++
    ) {
      fs.outputFileSync(
        `${parsePath.dir}/${parsePath.base}-PARTS/part-${i + 1}-${
          parsePath.base
        }`,
        fileBuffer.slice(
          SPARK_ASSET_SIZE_LIMIT * i,
          SPARK_ASSET_SIZE_LIMIT * (i + 1)
        )
      );

      const partPath = path.resolve(
        `${parsePath.dir}/${parsePath.base}-PARTS/part-${i + 1}-${
          parsePath.base
        }`
      );

      paths.push(partPath);
    }
  } else {
    paths.push(filePath);
  }

  return paths;
}

/*
 * Gets the set of paths that should be compressed.
 * 1. Only compresses files of a certain extension
 * 2. Doesn't compress files that are parts of a split file
 * 3. Doesn't compress files that are 0 length
 */
function getPathsToCompress(hashes, baseDirectory) {
  const paths = [];

  Object.entries(hashes).forEach(([key]) => {
    if (
      !key.includes('-PART') &&
      ['.css', '.html', '.htm', '.js'].includes(path.extname(key)) &&
      fs.pathExistsSync(path.resolve(baseDirectory, key)) &&
      fs.statSync(path.resolve(baseDirectory, key)).size > 0
    ) {
      paths.push(key);
    }
  });

  return paths;
}

function relativeToAbsoluteAssetPath(
  assetBaseLocation,
  filePath,
  url,
  mpContext
) {
  if (url.startsWith(`/${mpContext}`)) {
    url = url.substring(`/${mpContext}`.length);
  }

  if (url.startsWith('/')) {
    return path.join(assetBaseLocation, url);
  }

  return path.resolve(
    path.dirname(path.resolve(assetBaseLocation, filePath)),
    url
  );
}

module.exports = {
  isRemoteUrl,
  isInlineData,
  duplicateSparkEntries,
  splitFileLargerThanSparkAssetSizeLimit,
  getPathsToCompress,
  relativeToAbsoluteAssetPath,
};
