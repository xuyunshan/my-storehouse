const path = require('path');
const fs = require('fs-extra');
const get = require('lodash.get');
const homedir = require('os').homedir();
const Task = require('./helpers/task');
const SilentError = require('silent-error');

function buildPathToLocalTar(name, version) {
  return `local-repo/com/linkedin/${name}/${name}/${version}/linkedin-${name}-${version}.tgz`;
}

function buildPathToDedupedTar(name, version) {
  const hash = Math.floor(Math.random() * 0xffffffff).toString(16);

  return `./linkedin-${name}-${version}-${hash}.tgz`;
}

module.exports = class DependencyInstall extends Task {
  constructor({ mpLocation, snapshotDirectory = homedir, dependency } = {}) {
    super(...arguments);

    // name of the dependency, passed in as an environment var, will not contain @linkedin
    this.dependency = dependency;
    this.mpLocation = mpLocation;
    this.snapshotDirectory = snapshotDirectory;
  }

  /*
   * When a dependency test is run`mint dependency create-dependency` will
   * update ./build/dependency-spec.json with the "new" version of the dependency. This
   * will include a path to the snapshotted tarball for the dependency. We can grab that
   * path and then `yarn add <path>` to setup the project.
   */
  async run() {
    const dependencySpecPath = path.join(
      this.mpLocation,
      'build/dependency-spec.json'
    );

    if (!fs.existsSync(dependencySpecPath)) {
      throw new SilentError(
        `[pemberly-core] Could not find 'dependency-spec.json' at: ${dependencySpecPath}`
      );
    }

    const dependencySpecJson = fs.readJsonSync(dependencySpecPath);

    const productVersionToTestAgainst = get(
      dependencySpecJson,
      `product.${this.dependency}.version`,
      false
    );

    const pluginVersionToTestAgainst = get(
      dependencySpecJson,
      `build.toolchains.gradle.plugins.${this.dependency}.version`,
      false
    );

    const versionToTestAgainst =
      productVersionToTestAgainst || pluginVersionToTestAgainst;

    if (!versionToTestAgainst) {
      throw new SilentError(
        `[pemberly-core] Could not find ${this.dependency} defined in ${dependencySpecPath}`
      );
    }

    const tarPath = path.relative(
      this.mpLocation,
      path.join(
        this.snapshotDirectory,
        buildPathToLocalTar(this.dependency, versionToTestAgainst)
      )
    );

    const tarPathAbsolute = path.resolve(this.mpLocation, tarPath);

    if (!fs.existsSync(tarPathAbsolute)) {
      // dependency is not a node module so this task is not responsbile and we noop
      this.ui.writeLine(
        `Tarball not located at: ${tarPathAbsolute}. Assuming ${this.dependency} is not a node module.`
      );
      return;
    }

    // To work around Yarn caching tarballs with the same name (even if the contents change), we dedup the name
    // by applying a random hash
    const dedupedTarPath = buildPathToDedupedTar(
      this.dependency,
      versionToTestAgainst
    );
    await fs.copy(
      tarPathAbsolute,
      path.resolve(this.mpLocation, dedupedTarPath)
    );

    // this is a work-around for @linkedin/chrome-prebuilt. future work in that project would allow us to remove
    // the following manual linking
    let chromePrebuiltPath = false;
    const pathToChromeSymlink = './node_modules/.bin/google-chrome';

    if (fs.existsSync(pathToChromeSymlink)) {
      chromePrebuiltPath = fs.readlinkSync(pathToChromeSymlink);
    }

    // check if the dependency is a devDependency or a dependency
    const packageJson = fs.readJsonSync(
      path.join(this.mpLocation, 'package.json')
    );
    const yarnAddArgs = [
      'yarn',
      'add',
      `@linkedin/${this.dependency}@${dedupedTarPath}`,
    ];

    if (get(packageJson, `devDependencies.@linkedin/${this.dependency}`)) {
      yarnAddArgs.push('--dev');
    }

    // It turns out Yarn likes to create `npm_config_` environment variables that are all lowercase
    // Those don't get overwritten by the `env` setting below, and the lowercase variables seem to
    // win in the nested Yarn call. To work around this, completely remove any instance of
    // `npm_config_registry`, regardless of capitalization.

    for (const key in process.env) {
      if (key.toLowerCase && key.toLowerCase() === 'npm_config_registry') {
        delete process.env[key];
      }
    }

    const yarnAddCommand = this.createCommand({
      command: 'just',
      args: yarnAddArgs,
      options: {
        cwd: this.mpLocation,
        env: {
          // this prevents node-mp-bridge from erroring during install
          // with: Dependency changes detected in CI, aborting.
          DEPENDENT_PRODUCT_NAME: this.dependency,
          // this enables dependencies to be correctly installed
          // when using volta (as this was set via just)
          SASS_BINARY_SITE:
            'http://dev-artifactory.corp.linkedin.com:8081/artifactory/release/com/github/sass/node-sass-bindings/',
          CHROMEDRIVER_CDNURL:
            'http://dev-artifactory.corp.linkedin.com:8081/artifactory/release/com/github/giggio/chromedriver-binaries/',
          NPM_CONFIG_DISTURL:
            'http://dev-artifactory.corp.linkedin.com:8081/artifactory/release/org/nodejs/headers/',
          NPM_CONFIG_REGISTRY:
            'http://dev-artifactory.corp.linkedin.com:8081/artifactory/api/npm/npm-external-new/',
        },
      },
      ui: this.ui,
      mpLocation: this.mpLocation,
    });

    await yarnAddCommand.run();

    if (chromePrebuiltPath && !fs.existsSync(pathToChromeSymlink)) {
      fs.symlinkSync(chromePrebuiltPath, pathToChromeSymlink);
    }
  }
};

module.exports.buildPathToLocalTar = buildPathToLocalTar;
